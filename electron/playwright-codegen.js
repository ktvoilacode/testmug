/**
 * Playwright Code Generator - Generate .spec.js from recorded actions
 */

const fs = require('fs');

/**
 * Generate Playwright test code from recorded actions
 * @param {Object} session - Session object with actions
 * @param {Object} flowAnalysis - Optional flow analysis data
 * @returns {string} Playwright test code
 */
function generatePlaywrightCode(session, flowAnalysis = null) {
  const { id, actions, startUrl } = session;

  // Group actions by type to determine test description
  const hasLogin = actions.some(a =>
    a.selector?.includes('login') ||
    a.selector?.includes('password') ||
    a.selector?.includes('username')
  );

  const testName = hasLogin ? 'Login Flow Test' : 'Recorded User Flow';

  let code = `// Generated by Testmug - ${new Date().toISOString()}
// Session ID: ${id}

const { test, expect } = require('@playwright/test');

test.describe('${testName}', () => {
  test('replay recorded actions', async ({ page }) => {
`;

  // Add navigation to start URL if available
  if (startUrl) {
    code += `    // Navigate to starting URL\n`;
    code += `    await page.goto('${startUrl}');\n`;
    code += `    await page.waitForLoadState('domcontentloaded');\n\n`;
  }

  // Generate code for each action
  actions.forEach((action, index) => {
    code += `    // Action ${index + 1}: ${action.type}\n`;

    switch (action.type) {
      case 'navigate':
        if (action.url) {
          code += `    await page.goto('${action.url}');\n`;
          code += `    await page.waitForLoadState('domcontentloaded');\n`;
        }
        break;

      case 'click':
        if (action.selector) {
          code += `    await page.locator('${escapeSelectorQuotes(action.selector)}').click();\n`;
          if (action.text) {
            code += `    // Clicked: "${truncate(action.text, 50)}"\n`;
          }
        }
        break;

      case 'input':
        if (action.selector && action.value !== undefined) {
          code += `    await page.locator('${escapeSelectorQuotes(action.selector)}').fill('${escapeQuotes(action.value)}');\n`;
        }
        break;

      case 'keypress':
        if (action.key && action.selector) {
          code += `    await page.locator('${escapeSelectorQuotes(action.selector)}').press('${action.key}');\n`;
        }
        break;

      case 'scroll':
        if (action.scrollX !== undefined && action.scrollY !== undefined) {
          code += `    await page.evaluate(() => window.scrollTo(${action.scrollX}, ${action.scrollY}));\n`;
        }
        break;

      default:
        code += `    // Skipped: ${action.type}\n`;
    }

    code += `\n`;
  });

  // Add wait at the end
  code += `    // Wait for final state\n`;
  code += `    await page.waitForTimeout(1000);\n`;

  code += `  });\n`;
  code += `});\n`;

  return code;
}

/**
 * Escape quotes in selectors
 */
function escapeSelectorQuotes(selector) {
  return selector.replace(/'/g, "\\'");
}

/**
 * Escape quotes in values
 */
function escapeQuotes(value) {
  return String(value).replace(/'/g, "\\'");
}

/**
 * Truncate text to max length
 */
function truncate(text, maxLength) {
  if (!text) return '';
  return text.length > maxLength ? text.substring(0, maxLength) + '...' : text;
}

/**
 * Save Playwright code to file
 */
function savePlaywrightCode(filePath, code) {
  fs.writeFileSync(filePath, code, 'utf8');
  console.log('[CodeGen] Saved Playwright script:', filePath);
}

/**
 * Generate separate Playwright scripts for each detected flow
 * @param {Object} session - Session object with actions
 * @param {Object} flowAnalysis - Flow analysis with detected flows
 * @returns {Array} Array of {flowId, flowName, code} objects
 */
function generateFlowScripts(session, flowAnalysis) {
  if (!flowAnalysis || !flowAnalysis.flows || flowAnalysis.flows.length === 0) {
    console.log('[CodeGen] No flows detected, generating single script');
    return [{
      flowId: 'default',
      flowName: 'All Actions',
      flowType: 'mixed',
      code: generatePlaywrightCode(session)
    }];
  }

  console.log(`[CodeGen] Generating ${flowAnalysis.flows.length} flow-specific scripts`);

  return flowAnalysis.flows.map((flow) => {
    const flowActions = flow.actionIndices.map(idx => session.actions[idx - 1]).filter(Boolean);

    let code = `// Generated by Testmug - ${new Date().toISOString()}
// Session ID: ${session.id}
// Flow: ${flow.name} (${flow.type})
// Description: ${flow.description}

const { test, expect } = require('@playwright/test');

test.describe('${flow.name}', () => {
  test('${flow.description}', async ({ page }) => {
`;

    // Add navigation to start URL
    if (session.startUrl) {
      code += `    // Navigate to starting URL\n`;
      code += `    await page.goto('${session.startUrl}');\n`;
      code += `    await page.waitForLoadState('domcontentloaded');\n\n`;
    }

    // Generate code for each action in this flow
    flowActions.forEach((action, index) => {
      code += `    // Step ${index + 1}: ${action.type}\n`;

      switch (action.type) {
        case 'navigate':
          if (action.url) {
            code += `    await page.goto('${action.url}');\n`;
            code += `    await page.waitForLoadState('domcontentloaded');\n`;
          }
          break;

        case 'click':
          if (action.selector) {
            code += `    await page.locator('${escapeSelectorQuotes(action.selector)}').click();\n`;
            if (action.text) {
              code += `    // Clicked: "${truncate(action.text, 50)}"\n`;
            }
          }
          break;

        case 'input':
          if (action.selector && action.value !== undefined) {
            code += `    await page.locator('${escapeSelectorQuotes(action.selector)}').fill('${escapeQuotes(action.value)}');\n`;
          }
          break;

        case 'keypress':
          if (action.key && action.selector) {
            code += `    await page.locator('${escapeSelectorQuotes(action.selector)}').press('${action.key}');\n`;
          }
          break;

        case 'scroll':
          if (action.scrollX !== undefined && action.scrollY !== undefined) {
            code += `    await page.evaluate(() => window.scrollTo(${action.scrollX}, ${action.scrollY}));\n`;
          }
          break;

        default:
          code += `    // Skipped: ${action.type}\n`;
      }

      code += `\n`;
    });

    // Add assertions for this flow
    if (flow.assertions && flow.assertions.length > 0) {
      code += `    // Assertions for ${flow.type} flow\n`;
      flow.assertions.forEach((assertion, idx) => {
        code += `    // Assertion ${idx + 1}: ${assertion.description}\n`;

        switch (assertion.expectedCondition) {
          case 'visible':
            code += `    await expect(page.locator('${escapeSelectorQuotes(assertion.selector)}')).toBeVisible();\n`;
            break;

          case 'contains_text':
            if (assertion.expectedValue) {
              code += `    await expect(page.locator('${escapeSelectorQuotes(assertion.selector)}')).toContainText('${escapeQuotes(assertion.expectedValue)}');\n`;
            } else {
              code += `    await expect(page.locator('${escapeSelectorQuotes(assertion.selector)}')).toBeVisible();\n`;
            }
            break;

          case 'not_visible':
            code += `    await expect(page.locator('${escapeSelectorQuotes(assertion.selector)}')).not.toBeVisible();\n`;
            break;
        }
        code += `\n`;
      });
    }

    code += `    // Wait for final state\n`;
    code += `    await page.waitForTimeout(1000);\n`;
    code += `  });\n`;
    code += `});\n`;

    return {
      flowId: flow.flowId,
      flowName: flow.name,
      flowType: flow.type,
      code: code
    };
  });
}

/**
 * Save all flow scripts to separate files
 * @param {string} sessionId - Session ID
 * @param {Array} flowScripts - Array of flow script objects
 * @param {string} sessionsDir - Sessions directory path
 */
function saveFlowScripts(sessionId, flowScripts, sessionsDir) {
  const savedFiles = [];

  flowScripts.forEach((flowScript, idx) => {
    const fileName = flowScripts.length === 1
      ? `${sessionId}.spec.js`
      : `${sessionId}_${flowScript.flowId}.spec.js`;

    const filePath = require('path').join(sessionsDir, fileName);
    fs.writeFileSync(filePath, flowScript.code, 'utf8');

    console.log(`[CodeGen] Saved ${flowScript.flowType} flow script: ${fileName}`);
    savedFiles.push({
      flowId: flowScript.flowId,
      flowName: flowScript.flowName,
      flowType: flowScript.flowType,
      filePath: filePath
    });
  });

  return savedFiles;
}

module.exports = {
  generatePlaywrightCode,
  savePlaywrightCode,
  generateFlowScripts,
  saveFlowScripts
};
